from beanie import PydanticObjectId
from datetime import datetime

from app.crud.video_crud import video_crud
from app.crud.video_analytics_crud import video_analytics_crud
from app.models.video import Video, VideoAnalytics


class VideoService:

    @staticmethod
    async def upload_video(user_id: PydanticObjectId, zawiya_id: PydanticObjectId, data):
        """
        Create a new video entry before uploading.
        """
        video = await video_crud.create(
            title=data.title,
            description=data.description,
            video_url=data.video_url,
            thumbnail_url=data.thumbnail_url,
            duration=data.duration,
            size_in_mb=data.size_in_mb,
            format=data.format,
            user_id=user_id,
            zawiya_id=zawiya_id,
        )

        # Create analytics entry automatically
        await video_analytics_crud.create(video_id=video.id)

        return video

    @staticmethod
    async def get_video(video_id):
        return await video_crud.get(video_id)

    @staticmethod
    async def publish(video_id: PydanticObjectId):
        video = await video_crud.update(video_id, {"is_publish": True})
        return video

    @staticmethod
    async def unpublish(video_id: PydanticObjectId):
        video = await video_crud.update(video_id, {"is_publish": False})
        return video

    @staticmethod
    async def delete(video_id):
        return await video_crud.soft_delete(video_id)

    @staticmethod
    async def restore(video_id):
        return await video_crud.restore(video_id)

    # -------- WATCHING --------
    @staticmethod
    async def increase_views(video_id: PydanticObjectId):
        analytics = await video_analytics_crud.get_one(video_id=video_id)
        analytics.total_views += 1
        await analytics.save()
        return analytics

    @staticmethod
    async def update_watch_time(video_id: PydanticObjectId, seconds: float):
        analytics = await video_analytics_crud.get_one(video_id=video_id)
        analytics.total_watch_time += seconds
        await analytics.save()
        return analytics

    @staticmethod
    async def like(video_id: PydanticObjectId, user_id: PydanticObjectId):
        """
        Store who liked & update counts.
        """
        analytics = await video_analytics_crud.get_one(video_id=video_id)

        if not hasattr(analytics, "liked_users"):
            analytics.liked_users = []
        if not hasattr(analytics, "disliked_users"):
            analytics.disliked_users = []

        # If already liked, ignore
        if user_id in analytics.liked_users:
            return analytics

        # Remove dislike if present
        if user_id in analytics.disliked_users:
            analytics.disliked_users.remove(user_id)
            analytics.total_dislikes -= 1

        analytics.liked_users.append(user_id)
        analytics.total_likes += 1
        await analytics.save()
        return analytics

    @staticmethod
    async def dislike(video_id: PydanticObjectId, user_id: PydanticObjectId):
        analytics = await video_analytics_crud.get_one(video_id=video_id)

        if not hasattr(analytics, "liked_users"):
            analytics.liked_users = []
        if not hasattr(analytics, "disliked_users"):
            analytics.disliked_users = []

        # If already disliked, ignore
        if user_id in analytics.disliked_users:
            return analytics

        # Remove like if present
        if user_id in analytics.liked_users:
            analytics.liked_users.remove(user_id)
            analytics.total_likes -= 1

        analytics.disliked_users.append(user_id)
        analytics.total_dislikes += 1
        await analytics.save()
        return analytics

from pydantic import BaseModel
from typing import Optional


class VideoUploadSchema(BaseModel):
    title: str
    description: Optional[str] = None
    video_url: str
    thumbnail_url: Optional[str] = None
    duration: Optional[int]
    size_in_mb: Optional[float]
    format: Optional[str]


class WatchTimeSchema(BaseModel):
    seconds: float
from fastapi import APIRouter, Depends, UploadFile, File
from beanie import PydanticObjectId

from app.services.video_service import VideoService
from app.schemas.video_schema import VideoUploadSchema, WatchTimeSchema
from app.dependencies import get_current_user


router = APIRouter(prefix="/videos", tags=["Videos"])


# ---------------------- UPLOAD ----------------------
@router.post("/upload")
async def upload_video(payload: VideoUploadSchema, user=Depends(get_current_user)):
    return await VideoService.upload_video(
        user_id=user.id,
        zawiya_id=user.zawiya_id,
        data=payload
    )


# ---------------------- GET VIDEO ----------------------
@router.get("/{video_id}")
async def get_video(video_id: PydanticObjectId):
    return await VideoService.get_video(video_id)


# ---------------------- WATCH VIDEO ----------------------
@router.post("/{video_id}/view")
async def track_view(video_id: PydanticObjectId):
    return await VideoService.increase_views(video_id)


@router.post("/{video_id}/watch-time")
async def track_watch_time(video_id: PydanticObjectId, payload: WatchTimeSchema):
    return await VideoService.update_watch_time(video_id, payload.seconds)


# ---------------------- LIKE / DISLIKE ----------------------
@router.post("/{video_id}/like")
async def like(video_id: PydanticObjectId, user=Depends(get_current_user)):
    return await VideoService.like(video_id, user.id)


@router.post("/{video_id}/dislike")
async def dislike(video_id: PydanticObjectId, user=Depends(get_current_user)):
    return await VideoService.dislike(video_id, user.id)


# ---------------------- PUBLISH CONTROL ----------------------
@router.post("/{video_id}/publish")
async def publish_video(video_id: PydanticObjectId):
    return await VideoService.publish(video_id)


@router.post("/{video_id}/unpublish")
async def unpublish_video(video_id: PydanticObjectId):
    return await VideoService.unpublish(video_id)


# ---------------------- DELETE / RESTORE ----------------------
@router.delete("/{video_id}")
async def delete_video(video_id: PydanticObjectId):
    return await VideoService.delete(video_id)


@router.post("/{video_id}/restore")
async def restore_video(video_id: PydanticObjectId):
    return await VideoService.restore(video_id)
